---
title: "R e RStudio"
subtitle: "Semana 1"
author: "Bruno Montezano"
institute: "Programa de Pós-Graduação em Psiquiatria e Ciências do Comportamento\nUniversidade Federal do Rio Grande do Sul"
date: last-modified
date-format: long
lang: pt-br
execute:
  echo: true
format:
  revealjs:
    incremental: true
    theme: [default, ../assets/custom.scss]
    logo: "../assets/logo_ufrgs.png"
---

## Objetivos do curso

- Desenvolver habilidades básicas no manejo e visualização de dados em R
- Aprender conceitos básicos de programação
- Introduzir práticas de reprodutibilidade em pesquisa acadêmica
- Introduzir conceitos e rotinas de análise de dados em saúde

## Quem sou eu?

#### Bruno Montezano

- Psicólogo
- Mestrando em Psiquiatria e Ciências do Comportamento
- Integrante do grupo de pesquisa Alliance
- Pesquisa
  - Psiquiatria de precisão
  - Aprendizado de máquina
  - Transtorno bipolar
  - Suicídio
  
## Logística do curso

Onde?

. . .

::: {.nonincremental}
- Reuniões online
- Encontros presenciais
:::

. . .

Materiais: [https://brunomontezano.github.io/r-workshop/](https://brunomontezano.github.io/r-workshop/)

## Materiais

Todos os materiais do curso estarão no
[site do curso](https://brunomontezano.github.io/r-workshop/).

::: {.nonincremental}
- Slides e códigos usados para gerar os slides
- Links com outros materiais sugeridos
:::

Se algo não estiver funcionado no site, me enviem um email!

## Plano de ensino

1. R e RStudio
2. Fundamentos de estatística no R
3. Distribuições e associações
4. Visualização de dados
5. Inferência estatística
6. Modelos lineares
7. Modelos lineares generalizados

## Por que aprender análise quantitativa de dados?

*Vocês vão ler pesquisa quantitativa*

- Interpretação
- Avaliação 

. . .

*Vocês podem fazer pesquisa quantitativa*

- Análise
- Comunicação

## Mas precisamos mesmo de programação? {.smaller}

Sim. Programação é *importante*.

- Limpar dados na mão é:
  - Propenso a erros
  - Demorado
  - Não é **reprodutível**

- Programação pode nos abrir portas
  - Testar novos métodos
  - Melhor compreensão de resultados
  - Automatização de rotinas
  
- Mas a frustração nos acompanha nessa jornada...
  - A boa notícia é que nos acostumamos
  
## Formatação dos slides {.smaller}

**Negrito** indica um termo importante.

. . .

*Itálico* indica ênfase ou instruções para clicar com o mouse.

::: {.nonincremental}
- Exemplo: "Clique em *Arquivo > Salvar como...*".
:::

. . .

`Código` representa o código em R para ser digitado ou
teclas para realizar ações.

::: {.nonincremental}
- Exemplo: "Pressione `Ctrl-P` para abrir a janela de impressão".
:::

. . .

Os blocos de código são *código de fato executado no R*.

```{r exemplo-formatacao}
# Quanto dá 25 vezes 11?
25 * 11
```

## Por que usar R? {.smaller}

R é uma linguagem de programação construída para computação estatística.

. . .

Vamos supor que vocês já tenham domínio no Excel, SPSS, Stata, ou SAS, por quê usar R?

- R é gratuito, então não precisamos de licença
- R tem uma grande comunidade para pacotes e suporte
- R consegue trabalhar com *praticamente* qualquer formato de dado
- R *facilita* o processo de replicação e reprodutibilidade
- R é uma linguagem, então é capaz de fazer *quase tudo* (vide os slides e o [site do curso](https://brunomontezano.github.io/r-workshop/))
- R é parecido com outras linguagens de programação (Python, Julia, etc)

## RStudio {.smaller}

O RStudio é um ambiente de desenvolvimento integrado (IDE) para facilitar nossa vida.

- Organização do código, saídas e plots
- Autocompletar e destacar o código
- Ajuda a visualizar os dados e objetos
- Habilita integração de código em R em documentos com **Quarto** e **RMarkdown**

. . .

Além disso:

- Manejar repositórios `git`
- Rodar tutoriais interativos
- Lidar com outras linguagens de programação como Python, SQL e HTML

## Interface do RStudio {.smaller}

Vamos abrir o RStudio e ir em *Arquivo > Novo Arquivo > R Script*.

Vamos entender a interface:

- Canto superior esquerdo: **Editor** de código e visualizador de dados
- Canto inferior esquerdo: **Console** para rodar código (`>`)
- Canto superior direito: Lista de objetos no **Ambiente**, aba de **Histórico**
- Canto inferior direito: Abas para navegar pelos arquivos, ver plots, manejar
pacotes, e visualizar arquivos de ajuda

. . .

O layout pode ser modificado em *Ferramentas > Opções Globais > Layout do Painel*

## Editando e executando código em R

Podemos executar (rodar) nosso código de diversas formas:

- Selecionar linhas no **Editor** e clicar em *Executar* no topo ou pressione
`Ctrl+Enter` ou `⌘+Enter` para rodar a seleção

- Com o seu **cursor** (`|`) na linha que você quer executar,
pressione `Ctrl+Enter` ou `⌘+Enter`. Notem que o cursor se move para a próxima linha,
para que possamos rodar vários códigos em sequência

- Escreva linhas individuais no **Console** e pressione `Enter`

. . .

O **Console** vai mostrar as linhas que você rodou seguido pela saída.

## Código incompleto

Se você errar (por exemplo, esquecer de fechar um parênteses), o R pode mostrar um
`+` pedindo para que você complete o comando:

```{r codigo-incompleto}
#| eval: false
> (11 - 2
+
```

Ou finalize o comando, ou aperte `Esc` para sair dessa operação.

## R como calculadora

No **Console**, vamos digitar `111 + 222 + 333` e pressionar `Enter`.

```{r soma}
111 + 222 + 333
```

. . .

O `[1]` na saída indica o **índice** numérico do primeiro elemento da linha.

. . .

Agora, no nosso documento em R em branco no **Editor**, vamos digitar `sqrt(81)` e
clicar `Executar` ou pressionar `Ctrl+Enter` ou `⌘+Enter`.

```{r rodar-sqrt}
sqrt(81)
```

## Funções e Ajuda

`sqrt()` é um exemplo de **função** do R.

Se nós não soubermos o que `sqrt()` é, podemos digitar `?sqrt` no **Console** e ver
a aba de **Ajuda** na direita.

```{r ajuda-sqrt}
#| eval: false
?sqrt
```

. . .

**Argumentos** são as *entradas* de uma função. Nesse caso, o único argumento para
`sqrt()` é `x`, que pode ser um número ou um vetor de números.

Arquivos de ajuda provém documentação em como usar as funções e o que a função
retorna.

## Criando objetos {.smaller}

R armazena *tudo* como um **objeto**, incluindo dados, funções, modelos, e saída.

A criação de um objeto pode ser feita usando o **operador de atribuição**: `<-`

```{r criar-objeto}
novo_objeto <- 144
```

. . .

**Operadores** como o `<-` são funções que se parecem com símbolos mas geralmente ficam
entre argumentos (números ou objetos) ao invés de ter eles entre `()` como na função
`sqrt(x)`.^[Podemos chamar operadores como funções com crase: \`+\`(x, y)]

. . .

Nós fazemos contas matemáticas com operadores, por exemplo, `x + y`.

`+` é o operador de adição.

## Chamando objetos

Nós podemos mostrar ou "chamar" um objeto através do seu nome.

```{r chamar-objeto}
novo_objeto
```

. . .

Nomes de objetos podem conter `_` e `.`, mas não podem *começar* com números. Tente sempre
ser consistente ao nomear objetos.

. . .

Poder autocompletar seu código significa que *nomes longos são melhores que nomes vagos*!

Bons nomes previnem confusão.

## Usando objetos

Você pode tratar o **nome** do objeto como se ele fosse os valores armazenados no
próprio objeto.

. . .

```{r somar-dez}
novo_objeto + 10
```

```{r objeto-mais-objeto}
novo_objeto + novo_objeto
```

```{r sqrt-objeto}
sqrt(novo_objeto)
```

## Criando vetores

Um **vetor** é uma série de **elementos**, como números, por exemplo.

Nós podemos criar um vetor usando a função `c()` que significa "combinar".

```{r criar-vetor}
novo_objeto <- c(4, 9, 16, 25, 36)
novo_objeto
```

. . .

Atribuir em um nome já existente *sobrescreve esse objeto*.

. . .

Você pode usar um vetor como argumento para várias funções.

. . .

```{r sqrt-vetor}
sqrt(novo_objeto)
```

## Vetores de caractere

É comum trabalharmos com dados que são categóricos. Para criar um vetor com elementos
de texto — chamamos de **string** em programação — devemos inserir o texto entre aspas:

```{r vetor-de-caractere}
vetor_com_texto <- c("Eutimia", "Mania", "Depressão")
vetor_com_texto
```

. . .

Dados categóricos podem ser armazenados como um **fator**, usando uma representação
numérica subjacente. Cada possível valor de um fator transforma-se em um **nível**.

```{r vetor-fator}
vetor_em_fator <- factor(vetor_com_texto)
vetor_em_fator
```

## Salvando e carregando objetos

Nós podemos salvar um objeto do R como um arquivo para abrí-lo depois:

```{r salvar-objeto}
#| eval: false

save(novo_objeto, file = "novo_objeto.RData")
```

. . .

Nós também podemos carregar arquivos salvos do R:

```{r carregar-objeto}
#| eval: false

load("novo_objeto.RData")
```

. . .

Onde esses arquivos estão sendo salvos? E de onde eles estão sendo carregados?

## Diretório de trabalho

O R salva e busca por arquivos para abrir no nosso **diretório de trabalho** atual.
Nós podemos solicitar para o R que pasta é essa:

```{r getwd}
getwd()
```

. . .

Da mesma forma, podemos especificar um novo diretório de trabalho:

```{r setwd}
#| eval: false

setwd("/home/bruno/Documentos/Pesquisa_Pos_Graduacao/")
```

## Objetos mais complexos {.smaller}

Os mesmos princípios podem ser usados para criar objetos mais complexos:

::: {.nonincremental}
- **Matrizes**
- **Arrays**
- **Listas**
- **Dataframes**
:::

. . .

A maioria dos conjuntos de dados que nós trabalhamos em saúde são lidos no R e
armazenados como **dataframes**.

Portanto, nós vamos focar na manipulação e análise de dataframes.

# Dataframes

## Vamos falar sobre Íris (`iris`)?

No nosso script em R, vamos carregar os dados `iris`.

. . .

```{r carregar-iris}
data(iris)
```

`data(iris)` carrega o dataframe no nosso **Ambiente Global**.

. . .

`View(iris)` mostra um painel de visualização da base (usar apenas no **Console**,
é uma má prática incluir no seu script). Também podemos usar outras funções:

. . .

```{r funcao-head}
head(iris, n = 5) # Exibir as 5 primeiras linhas, tail() exibe as últimas
```

## Vamos seguir explorando as `iris` {.smaller}

`str()` mostra a estrutura de um objeto:

```{r funcao-str}
str(iris) # e[str]utura
```

. . .

`summary()` mostra um resumo do objeto:

```{r funcao-summary}
summary(iris)
```

A função `summary()` mostra informações diferentes para tipos diferentes de objeto.

# Indexando e criando subconjuntos com R

## Índices e dimensões {.smaller}

No R base, existem duas maneiras de acessar elementos de um objeto: colchetes
(`[]` ou `[[]]`) e `$`. A forma como acessamos o objeto depende de suas *dimensões*.

. . .

Dataframes têm *2 dimensões*: **linhas** e **colunas**. Colchetes nos permitem
numericamente extrair **subconjuntos** no formato `objeto[linha, coluna]`. Deixar
o local da linha ou coluna em branco seleciona *todos* elementos daquela dimensão.

```{r primeira-linha-iris}
iris[1, ] # Primeira linha da base iris
```

. . .

```{r subset-iris}
iris[1:3, 4:5] # Três primeiras linhas, quarta e quinta coluna
```

O **operador dois pontos** (`:`) gera um vetor usando a sequência de números inteiros do
primeiro até o segundo argumento. `1:3` equivale a `c(1, 2, 3)`.

## Dataframes e nomes {.smaller}

Colunas em dataframes também podem ser acessadas usando seus nomes com o operador de extração
`$`. Ele retorna a coluna extraída como um vetor:

```{r subset-com-cifrao}
iris$Sepal.Length[1:10]
```

. . .

Percebam que eu usei os colchetes para selecionar apenas os primeiros 10 elementos da coluna.

Nós podemos combinar os formatos de subconjuntos! Nesse caso nós usamos apenas um único valor
(sem índice de coluna), porque os **vetores** possuem *apenas uma dimensão* (comprimento).

Se você tentar criar um subconjunto e receber um aviso quanto ao "número incorreto de
dimensões", verifique o seu subconjunto!

## Indexando por expressões

Também podemos indexar usando expressões — ou seja, testes lógicos.

```{r subset-expressao}
iris[iris$Petal.Length > 6.5, ]
```


## Como as expressões funcionam {.smaller}

O que `iris$Petal.Length > 6.5` faz internamente?

```{r como-expressoes-funcionam}
iris$Petal.Length > 6.5
```

. . .

Ela retorna um vetor de valores `TRUE` ou `FALSE`.

Ao usar com o operador de subconjunto (`[]`), elementos que receberam um `TRUE` são
retornados enquanto àqueles que receberam um `FALSE` são descartados.

## Operadores lógicos {.smaller}

Nós usamos o `>` para testar "maior que": `iris$Petal.Length > 6.5`

. . .

Existem vários outros **operadores lógicos**:

- `==`: igual a
- `!=`: não é igual a
- `>`, `>=`, `<`, `>=`: menor que, menor que ou igual a, etc
- `%in%`: usado para checar igual a um entre vários valores

. . .

E também podemos combinar múltiplas condições lógicas:

- `&`: ambas condições precisam ser respeitadas (E)
- `|`: pelo menos uma condição precisa ser respeitada (OU)
- `!`: inverte uma condição lógica (`TRUE` vira `FALSE`, `FALSE` vira `TRUE`)

. . .

Operadores lógicos são um dos pilares da programação. Experimente com alguns deles
para se familiarizar em como eles funcionam!

## Adendo: valores ausente

Valores ausentes são codificados como `NA` sem aspas:

```{r vetor-missing}
vetor_com_missing <- c(1, 2, NA, 4, 5, 6, NA)
```

Apenas um `NA` "contamina tudo": Você receberá NA dos seus cálculos a menos que
os remova manualmente ou use um argumento extra `na.rm = TRUE` em algumas
funções:

```{r media-sem-narm}
mean(vetor_com_missing)
```

. . .

Podemos pegar os missings (`NA`) e removê-los (`rm`):

```{r media-com-narm}
mean(vetor_com_missing, na.rm = TRUE)
```

## Encontrando valores ausentes {.smaller}

**LEMBRETE:** Não podemos testar por valores ausentes vendo se eles são "iguais a" (`==`) `NA`:

```{r igual-a-na}
vetor_com_missing == NA
```

. . .

Mas podemos usar a função `is.na()`:

```{r funcao-isna}
is.na(vetor_com_missing)
```

. . .

Poderíamos criar um subconjunto para chegar na mesma média com `na.rm = TRUE`:

```{r media-subconjunto-sem-missing}
mean(vetor_com_missing[!is.na(vetor_com_missing)])
```

`!` inverte uma condição lógica. Lemos o subconjunto acima como "retorne os não-`NA`".


## Vamos aprender com o pacote![Pacote swirl](../assets/logo_swirl.png)

## Instalando pacotes {.smaller}

Assim como nós almejamos que o paciente seja terapeuta de si mesmo, aqui podemos
tentar que você sejam professores de si mesmos.

. . .

Para isso, vamos instalar um **pacote** chamado `swirl`.

. . .

**Pacotes** contêm funções e/ou dados incorporados que podemos utilizar.
A potência do R vem dos pacotes!

. . .

No *Console*, digite `install.packages("swirl")`.

- Notem que o *nome do pacote a ser instalado deve estar entre aspas*. Isso se
dá porque o nome é um termo de busca (texto), e não um objeto!

- Uma vez instalado um pacote, vocês não precisam reinstalá-lo até atualizar o R.
Logo, não devemos incluir `install.packages()` em nossos scripts.

. . .

Nós podemos carregar os pacotes como o `swirl` usando a função `library()`.

```{r carregar-swirl}
#| eval: false
library(swirl)
```

## Tarefa de casa {.smaller}

- [Dar uma olhada no site do curso](https://brunomontezano.github.io/r-workshop/)

- Explorar alguns tutoriais do `swirl`
  - Use `library(swirl)` para carregar o pacote
  - Após carregado, use `swirl()` para iniciar a interface de tutoriais
    - *Leia as instruções!*
  - Experimente as aulas de `R Programming` — estamos em torno da aula 5

- Exercícios
  - Crie um vetor de 1 a 25 e armazene em uma variável de nome `sequencia`
  (lembrem-se do operador `:`).
  - Crie um vetor de caractere de dois elementos com seu nome e último nome
  (chamado `nome_completo`) e extraia seu sobrenome usando `[]`.
  - Filtrem a base `iris` com apenas as plantas da espécie 
  `setosa` (lembrem-se do `$`, do `==`, do `[]`,
  das aspas ao trabalhar com texto)

## Dica: ChatGPT

- O [ChatGPT](https://chat.openai.com/chat) é um assistente virtual que pode ajudar
na aprendizagem de programação
em R para pesquisadores em saúde
- Ele pode responder a perguntas sobre sintaxe, funcionalidades e solução de problemas no R

. . .

Você pode utilizar o pacote [`gptstudio`](https://github.com/MichelNivard/GPTstudio)
para auxiliar nos códigos, gramática dos documentos,
ou para comentar seu código no RStudio.